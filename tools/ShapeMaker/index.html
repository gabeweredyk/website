<!DOCTYPE html>
<html lang="en">
  <head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        html, body {
  margin: 0;
  padding: 0;
  display: flex;

  /* This centers our sketch horizontally. */
  justify-content: center;

  /* This centers our sketch vertically. */
  align-items: center;
  background-color: #222222;
  color: white;
}
canvas {
  display: block;
}

    </style>
    <meta charset="utf-8" />

  </head>
  <body>
    <p>
      A - Add straight <br/>
      S - Add curve <br />
      D - Delete most recent addition <br />
      F - Toggle percise inputs <br />
      G - Impose curve on background <br />
      Z - Undo imposition <br />
      Alt - Mirror precious point <br />
      Shift - Mirror next point <br />
      Enter - Log set of points
    </p>
    <script>

//currently selected point
var currentP = -1;

// Array of the points
var p;
var curved = [];

// width;
var w;

//radius of a point
const r = 10;

var points = [];
var previous = [];

//Pascal array, and how many iterations (How many points will the curve have?) 
const PASCAL_CAP = 10;
var pascal = [[1]];

//percision of lines and line colors
const RESOLUTION = 20;
var pause = false;

var inputing = false;
var x, y;

function setup() {
  // Generate pascal triangle
  for (let i = 1; i < PASCAL_CAP; i++){
    pascal.push([1]);
    for (let j = 1; j < i; j++){
      pascal[i].push(pascal[i - 1][j] + pascal[i - 1][j - 1]);
    }
    pascal[i].push(1);
  }

  w = min(windowWidth, windowHeight);

  //Generate starting position for points, places them in circle
  p = [createVector(w / 2, w / 2)];

  x = createInput();
  x.position(300, 20);
  x.attribute("type", "number");
  y = createInput();
  y.position(300, 50);
  y.attribute("type", "number");
  
  cnv = createCanvas(w, w);
}

function draw() {
    background(24);
    if (pause) return;
    points = Array();

    if (inputing){
        stroke("white");
        strokeWeight(5);
        noFill();
        rectMode(CORNERS);
        rect(0, 0, w, w);
    }
  
    drawCurve();
    
    drawPoints();
}

function drawCurve(){
    stroke("#bbbbbb");
    strokeWeight(1);
    noFill();
    for (let i = 0; i < previous.length; i++){
      beginShape();
      for (let j = 0; j < previous[i].length; j++){
          vertex(previous[i][j][0] * w, previous[i][j][1] * w);
      }
      endShape(CLOSE);
    }
    stroke("white");
    strokeWeight(4);
    beginShape();
    for (let i = 0, l = 0; i < p.length; i++, l++){
        if (curved[l]){
          var arr = p.slice(i, i + 3);
          Bezier(arr, RESOLUTION);
          i++;
        }
        else{
          points.push([p[i].x / w, p[i].y / w]);
          vertex(p[i].x, p[i].y);   
        }
    }
    endShape();
}


//Control values of mouseX and mouseY
function clampMouse(x){
    return min(w, max(0, x));
}


//CONTROL POINTS
function drawPoints(){
    //fix tangency, need to fix
    if (mouseIsPressed && !inputing){
      movePoints();
      let i = currentP;
      if (keyIsDown(16) && i < p.length - 2){
        p[i + 2].x = 2 * p[i + 1].x - p[i].x;
        p[i + 2].y = 2 * p[i + 1].y - p[i].y;
      }
      if (keyIsDown(18) && i > 1){
        p[i - 2].x = 2 * p[i - 1].x - p[i].x;
        p[i - 2].y = 2 * p[i - 1].y - p[i].y;
      }
    }

    //inputs
    ellipseMode(RADIUS);
    noFill();
    colorMode(HSB);
    for (let i = 0; i < p.length; i++){
        stroke(255 * i / p.length, 255, 255);
        strokeWeight(1);
        ellipse(p[i].x, p[i].y, r, r);
        strokeWeight(4);
        point(p[i].x, p[i].y);
    }
  colorMode(RGB);

}

function mousePressed(){
    for (let i = 0; i < p.length; i++){
        if (dist(p[i].x, p[i].y, clampMouse(mouseX), clampMouse(mouseY)) < r){
            if (inputing){
                p[i].x = x.value() * w;
                p[i].y = y.value() * w;
            }
            currentP = i;
            return;
        }
    }
    currentP = -1;
}

function movePoints(){
    if (currentP < 0) return;
    p[currentP].x = clampMouse(mouseX);
    p[currentP].y = clampMouse(mouseY);
}
//

//ACTUAL CURVE
function Bezier(b, a){
    var n = b.length - 1;
    for (let temp = 0; temp <= a; temp++){
        let t = temp / a;
        var sum = createVector(0, 0);
        for (let i = 0; i <= n; i++){
        sum.x += pascal[n][i] * pow(1 - t, n - i) * pow(t, i) * b[i].x;
        sum.y += pascal[n][i] * pow(1 - t, n - i) * pow(t, i) * b[i].y;
        }
        points.push([sum.x / w, sum.y / w]);
        vertex(sum.x, sum.y);
    }
}
//

function keyPressed(){
  if (keyCode === 13){ //enter
    console.log(points);
  }
  if (key == "a" && !inputing){ //a
    p.push(createVector(clampMouse(mouseX), clampMouse(mouseY)));
    curved.push(false);
  }
  if (key == "s" && !inputing){ //s
    p.push(createVector((clampMouse(mouseX) + p.at(-1).x) / 2, (clampMouse(mouseY) + p.at(-1).y) / 2));
    p.push(createVector(clampMouse(mouseX), clampMouse(mouseY)));
    curved.push(true);
  }
  if (key == "d"){ //d
    if (p.length == 1) return;
    p = p.slice(0, p.length - 1);
    if (curved.at(-1)) {
      p = p.slice(0, p.length - 1);
    }
    curved = curved.slice(0, curved.length - 1);
  }
  if (key == "f") { // f
      inputing = !inputing;
  }
  if (key == "g"){ // g
    pause = true;
    previous.push(points);
    console.log(previous);
    p = [createVector(w /2, w /2)];
    curved = [];
    pause = false;
  }
  if (key == "z"){ // z
      previous = previous.slice(0, previous.length - 1);
  }
}


    </script>
  </body>
</html>
